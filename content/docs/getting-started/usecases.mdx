---
title: Use Cases
description: Real-world examples and patterns for using Spry in production
icon: Lightbulb
index: 5
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

## Overview

This guide showcases real-world use cases and proven patterns for leveraging Spry's executable Markdown capabilities. Each recipe is production-ready and can be adapted to your specific needs.

<Callout type="info">
**Recipe Format**

Each recipe includes:
- Clear goals and outcomes
- Complete, working code examples
- Step-by-step implementation guide
- Tips for customization and extension
</Callout>

<Cards>
  <Card title="Compliance & Audit" icon="Shield">
    Automate evidence collection and audit trails
  </Card>
  
  <Card title="Data Applications" icon="Database">
    Build interactive dashboards with SQLPage
  </Card>
  
  <Card title="DevOps Automation" icon="Server">
    Create executable runbooks for deployment
  </Card>
</Cards>

## Recipe 1: Audit-Ready Evidence (Policies as Code)

**Goal:** Create verifiable test case documents that capture status and link to automated results - perfect for compliance frameworks like CMMC, SOC2, or ISO 27001.

<Callout type="success">
**Why This Pattern Works**

By embedding tests directly in documentation, you ensure evidence collection is automated, repeatable, and version-controlled. The test cases become living documents that prove compliance.
</Callout>

<Steps>
  <Step>
    ## Create a Test Case Document
    
    Create `test-case-TC001.md` with frontmatter classification:

    ```markdown
    ---
    doc-classify:
      role: evidence
      framework: CMMC
      control: AC.L1-3.1.1
      status: pending
    ---

    # Test Case TC-001: Access Control Verification

    ## Objective

    Verify that system access is limited to authorized users.

    ## Prerequisites

    - Access to the production system
    - Admin credentials (stored in vault)

    ## Test Steps

    \`\`\`bash tc001-check-access --descr "Verify access controls are in place"
    #!/usr/bin/env -S bash
    set -e

    # Check that only authorized users have access
    authorized_users=$(cat /etc/security/authorized_users)
    current_users=$(who | awk '{print $1}' | sort -u)

    for user in $current_users; do
      if ! echo "$authorized_users" | grep -q "^$user$"; then
        echo "FAIL: Unauthorized user detected: $user"
        exit 1
      fi
    done

    echo "PASS: All current users are authorized"
    \`\`\`

    ## Evidence Artifacts

    \`\`\`bash tc001-capture-evidence -C ./evidence/tc001-results.json --gitignore
    #!/usr/bin/env -S bash
    cat << EOF
    {
      "testCase": "TC-001",
      "executedAt": "$(date -Iseconds)",
      "result": "PASS",
      "authorizedUserCount": $(wc -l < /etc/security/authorized_users),
      "currentUserCount": $(who | wc -l)
    }
    EOF
    \`\`\`

    ## Results

    | Check | Status | Evidence |
    |-------|--------|----------|
    | User Authorization | Pending | [Results JSON](./evidence/tc001-results.json) |
    ```

    <Callout>
    **Frontmatter Classification**

    The `doc-classify` frontmatter enables filtering and reporting across multiple test cases, making it easy to generate compliance reports.
    </Callout>
  </Step>

  <Step>
    ## Execute the Test Case
    
    Run the test and capture evidence automatically:

    ```bash
    # Run the test case
    ./spry.ts rb run test-case-TC001.md

    # View the captured evidence
    cat ./evidence/tc001-results.json
    ```

    **Example Output:**
    ```json
    {
      "testCase": "TC-001",
      "executedAt": "2025-01-15T10:30:00-05:00",
      "result": "PASS",
      "authorizedUserCount": 12,
      "currentUserCount": 3
    }
    ```
  </Step>

  <Step>
    ## Update Status Based on Results
    
    After execution, update the frontmatter to reflect the test outcome:

    ```yaml
    ---
    doc-classify:
      role: evidence
      framework: CMMC
      control: AC.L1-3.1.1
      status: passed
      last-executed: 2025-01-15T10:30:00Z
    ---
    ```

    <Callout type="success">
    **Audit Trail**

    The combination of version-controlled test cases, automated execution, and timestamped evidence creates a complete audit trail that satisfies compliance requirements.
    </Callout>
  </Step>
</Steps>

### Extending This Pattern

<Tabs items={['Multiple Controls', 'Scheduled Testing', 'Report Generation']}>
  <Tab value="Multiple Controls">
    **Testing Multiple Controls**

    Create a directory structure organized by control:

    ```
    compliance/
    ├── AC-L1-3.1.1/
    │   ├── TC-001-access-control.md
    │   └── TC-002-session-timeout.md
    ├── AU-L2-3.3.1/
    │   └── TC-003-audit-logging.md
    └── run-all-tests.sh
    ```

    Run all tests:
    ```bash
    ./spry.ts rb run compliance/**/*.md --summarize
    ```
  </Tab>

  <Tab value="Scheduled Testing">
    **Automated Scheduled Testing**

    Add a cron job for continuous compliance:

    ```bash
    # Run tests daily at 2 AM
    0 2 * * * cd /opt/compliance && ./spry.ts rb run **/*.md --verbose json > daily-results.json
    ```

    Or use GitHub Actions:
    ```yaml
    name: Compliance Tests
    on:
      schedule:
        - cron: '0 2 * * *'
    jobs:
      test:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v2
          - run: ./spry.ts rb run compliance/**/*.md
    ```
  </Tab>

  <Tab value="Report Generation">
    **Generate Compliance Reports**

    Create a summary report generator:

    ```bash
    # Generate HTML report
    ./spry.ts rb run compliance/**/*.md --format html > compliance-report.html

    # Generate JSON for dashboard integration
    ./spry.ts rb run compliance/**/*.md --format json | \
      jq '.results[] | {control, status, lastExecuted}' > dashboard-data.json
    ```
  </Tab>
</Tabs>

---

## Recipe 2: Building a Data Application (SQLPage)

**Goal:** Create a SQLite-backed dashboard application using SQLPage - no JavaScript framework required, just SQL and Markdown.

<Callout type="info">
**SQLPage Benefits**

SQLPage lets you build full-featured web applications using only SQL queries. Combined with Spry, you get version control, templating, and deployment automation.
</Callout>

<Steps>
  <Step>
    ## Initialize the Project
    
    Create a new SQLPage project with Spry:

    ```bash
    mkdir sales-dashboard && cd sales-dashboard
    deno run --node-modules-dir=auto -A \
      https://raw.githubusercontent.com/programmablemd/spry/main/lib/playbook/sqlpage/cli.ts init
    ```

    This creates:
    - `spry.ts` - CLI wrapper
    - `Spryfile.md` - Application definition (we'll customize this)
    - `sqlpage/sqlpage.json` - SQLPage configuration
    - `import_map.json` - Deno imports
  </Step>

  <Step>
    ## Define Your Application in Spryfile.md
    
    Replace the contents of `Spryfile.md`:

    ````markdown
    ---
    sqlpage-conf:
      database_url: ${env.SPRY_DB}
      web_root: ./dev-src.auto
      port: ${env.PORT}
      allow_exec: true
    ---

    # Sales Dashboard Application

    ## Environment Setup

    \`\`\`envrc prepare-env -C ./.envrc --gitignore
    export SPRY_DB="sqlite://sales.db?mode=rwc"
    export PORT=9227
    \`\`\`

    ## Database Schema

    \`\`\`bash prepare-db --descr "Create the sales database"
    #!/usr/bin/env -S bash
    rm -f sales.db
    sqlite3 sales.db << 'SQL'
    CREATE TABLE sales (
      id INTEGER PRIMARY KEY,
      product TEXT NOT NULL,
      amount DECIMAL(10,2) NOT NULL,
      sale_date DATE NOT NULL,
      region TEXT NOT NULL
    );

    INSERT INTO sales (product, amount, sale_date, region) VALUES
      ('Widget A', 150.00, '2025-01-01', 'North'),
      ('Widget B', 250.00, '2025-01-02', 'South'),
      ('Widget A', 175.00, '2025-01-03', 'East'),
      ('Widget C', 300.00, '2025-01-04', 'West'),
      ('Widget B', 225.00, '2025-01-05', 'North');
    SQL
    \`\`\`

    ## Application Layout

    \`\`\`sql PARTIAL global-layout.sql --inject **/*
    SELECT 'shell' AS component,
           'Sales Dashboard' AS title,
           'chart' AS icon,
           'fluid' AS layout,
           'index.sql' AS link,
           '{"link":"/index.sql","title":"Home"}' AS menu_item,
           '{"link":"/sales.sql","title":"Sales"}' AS menu_item,
           '{"link":"/regions.sql","title":"Regions"}' AS menu_item;
    \`\`\`

    ## Home Page

    \`\`\`sql index.sql { route: { caption: "Home" } }
    SELECT 'card' AS component,
           'Sales Dashboard' AS title,
           2 AS columns;

    SELECT 'Total Sales' AS title,
           '$' || SUM(amount) AS description
    FROM sales;

    SELECT 'Total Transactions' AS title,
           COUNT(*) || ' orders' AS description
    FROM sales;
    \`\`\`

    ## Sales Report

    \`\`\`sql sales.sql { route: { caption: "Sales Report" } }
    SELECT 'text' AS component,
           'Sales Report' AS title;

    SELECT 'table' AS component,
           TRUE AS sort,
           TRUE AS search;

    SELECT
      product AS "Product",
      '$' || amount AS "Amount",
      sale_date AS "Date",
      region AS "Region"
    FROM sales
    ORDER BY sale_date DESC;
    \`\`\`

    ## Regional Summary

    \`\`\`sql regions.sql { route: { caption: "By Region" } }
    SELECT 'text' AS component,
           'Sales by Region' AS title;

    SELECT 'chart' AS component,
           'bar' AS type,
           'Region' AS xtitle,
           'Total Sales' AS ytitle;

    SELECT
      region AS x,
      SUM(amount) AS y
    FROM sales
    GROUP BY region
    ORDER BY SUM(amount) DESC;
    \`\`\`
    ````

    <Callout>
    **PARTIAL Directive**

    The `PARTIAL global-layout.sql --inject **/*` automatically injects the navigation shell into every SQL page, ensuring consistent layout across your application.
    </Callout>
  </Step>

  <Step>
    ## Build and Run
    
    Execute the setup and start the application:

    ```bash
    # Set up environment
    source .envrc  # or use direnv

    # Prepare the database
    ./spry.ts rb task prepare-db

    # Build the SQLPage site
    ./spry.ts sp spc --fs dev-src.auto --destroy-first --conf sqlpage/sqlpage.json

    # Start SQLPage server
    sqlpage
    ```

    Visit `http://localhost:9227` to see your dashboard!

    <Callout type="success">
    **Your Dashboard is Live**

    You should see a fully functional dashboard with navigation, cards showing sales metrics, an interactive table, and a bar chart.
    </Callout>
  </Step>

  <Step>
    ## Development with Live Reload
    
    For active development with automatic rebuilding:

    ```bash
    ./spry.ts sp spc --fs dev-src.auto --destroy-first \
      --conf sqlpage/sqlpage.json --watch --with-sqlpage
    ```

    Now any changes to `Spryfile.md` will automatically:
    - Rebuild the SQL files
    - Restart the SQLPage server
    - Reflect in your browser (after refresh)
  </Step>

  <Step>
    ## Deploy to Production
    
    Package everything into the database for deployment:

    ```bash
    ./spry.ts sp spc --package --conf sqlpage/sqlpage.json | sqlite3 sales.db
    ```

    This stores all SQL files in the `sqlpage_files` table within `sales.db`.

    **Deploy:**
    ```bash
    # Copy the single database file to production
    scp sales.db user@server:/opt/app/

    # On the server, just run SQLPage
    cd /opt/app && sqlpage
    ```

    <Callout type="info">
    **Self-Contained Deployment**

    Your entire application - schema, data, and pages - lives in a single SQLite file. This makes deployment, backup, and distribution incredibly simple.
    </Callout>
  </Step>
</Steps>

### Customization Ideas

<Cards>
  <Card title="Add Authentication" icon="Lock">
    Use SQLPage's authentication components to add login and user sessions
  </Card>
  
  <Card title="Real-Time Updates" icon="RefreshCw">
    Add auto-refresh with meta tags or HTMX for live dashboards
  </Card>
  
  <Card title="Export Features" icon="Download">
    Add CSV/PDF export buttons using SQLPage's file generation
  </Card>
  
  <Card title="Multi-Tenant" icon="Users">
    Add tenant filtering in queries for SaaS applications
  </Card>
</Cards>

---

## Recipe 3: Executable Runbooks (DevOps)

**Goal:** Define an automated server health check and deployment workflow with dependency management, error handling, and rollback capabilities.

<Callout type="success">
**Runbook Benefits**

Executable runbooks capture DevOps procedures as code, making them testable, version-controlled, and consistently executable. No more copy-pasting commands from wiki pages!
</Callout>

<Steps>
  <Step>
    ## Create the Runbook
    
    Create `deployment-runbook.md`:

    ````markdown
    ---
    runbook:
      name: Production Deployment
      version: 1.0.0
      author: DevOps Team
    ---

    # Production Deployment Runbook

    This runbook automates the deployment process with health checks.

    ## Pre-Flight Checks

    \`\`\`bash check-git-status --descr "Verify clean git working directory"
    #!/usr/bin/env -S bash
    set -e

    if [ -n "$(git status --porcelain)" ]; then
      echo "ERROR: Working directory is not clean"
      git status --short
      exit 1
    fi

    echo "OK: Git working directory is clean"
    \`\`\`

    \`\`\`bash check-tests --descr "Run test suite" --depends check-git-status
    #!/usr/bin/env -S bash
    set -e

    echo "Running test suite..."
    npm test

    if [ $? -eq 0 ]; then
      echo "OK: All tests passed"
    else
      echo "ERROR: Tests failed"
      exit 1
    fi
    \`\`\`

    ## Build Phase

    \`\`\`bash build-app --descr "Build production artifacts" --depends check-tests
    #!/usr/bin/env -S bash
    set -e

    echo "Building production artifacts..."
    npm run build

    echo "OK: Build completed successfully"
    ls -la dist/
    \`\`\`

    ## Health Check

    \`\`\`bash health-check --descr "Verify server health"
    #!/usr/bin/env -S bash
    set -e

    SERVER_URL="${SERVER_URL:-http://localhost:3000}"

    echo "Checking server health at $SERVER_URL..."

    response=$(curl -s -o /dev/null -w "%{http_code}" "$SERVER_URL/health")

    if [ "$response" = "200" ]; then
      echo "OK: Server is healthy (HTTP $response)"
    else
      echo "ERROR: Server health check failed (HTTP $response)"
      exit 1
    fi
    \`\`\`

    ## Deployment

    \`\`\`bash deploy --descr "Deploy to production" --depends build-app,health-check
    #!/usr/bin/env -S bash
    set -e

    echo "Deploying to production..."

    # Example: Deploy to server
    rsync -avz --delete dist/ user@server:/var/www/app/

    echo "Restarting application..."
    ssh user@server 'systemctl restart app'

    echo "OK: Deployment completed"
    \`\`\`

    ## Post-Deployment Verification

    \`\`\`bash verify-deployment --descr "Verify deployment success" --depends deploy
    #!/usr/bin/env -S bash
    set -e

    echo "Verifying deployment..."
    sleep 10  # Wait for app to start

    response=$(curl -s -o /dev/null -w "%{http_code}" "http://production-server/health")

    if [ "$response" = "200" ]; then
      echo "OK: Deployment verified successfully"
    else
      echo "ERROR: Post-deployment verification failed"
      exit 1
    fi
    \`\`\`

    ## Rollback (Manual)

    \`\`\`bash rollback --descr "Rollback to previous version"
    #!/usr/bin/env -S bash
    set -e

    echo "Rolling back to previous version..."
    ssh user@server 'cd /var/www/app && git checkout HEAD~1 && systemctl restart app'

    echo "Rollback completed"
    \`\`\`
    ````

    <Callout>
    **Dependency Graph**

    The `--depends` flag creates a dependency graph, ensuring tasks run in the correct order. Spry automatically builds and executes the DAG.
    </Callout>
  </Step>

  <Step>
    ## Visualize the Execution Plan
    
    Before running, view the task dependency graph:

    ```bash
    # List all tasks and their dependencies
    ./spry.ts rb ls deployment-runbook.md

    # Visualize the DAG
    ./spry.ts rb run deployment-runbook.md --visualize plain
    ```

    **Example Output:**
    ```
    Execution Plan:
    Layer 0: check-git-status, health-check
    Layer 1: check-tests
    Layer 2: build-app
    Layer 3: deploy
    Layer 4: verify-deployment
    ```
  </Step>

  <Step>
    ## Execute the Runbook
    
    Run the complete deployment pipeline:

    <Tabs items={['Full Pipeline', 'Specific Task', 'With Summary']}>
      <Tab value="Full Pipeline">
        ```bash
        # Execute all tasks in dependency order
        ./spry.ts rb run deployment-runbook.md --verbose rich
        ```

        This runs the entire pipeline with rich progress output, stopping on any error.
      </Tab>

      <Tab value="Specific Task">
        ```bash
        # Run only the deploy task (and its dependencies)
        ./spry.ts rb task deploy deployment-runbook.md
        ```

        This executes only `deploy` and any tasks it depends on.
      </Tab>

      <Tab value="With Summary">
        ```bash
        # Execute with concise summary
        ./spry.ts rb run deployment-runbook.md --summarize
        ```

        Shows a summary of task execution with success/failure indicators.
      </Tab>
    </Tabs>
  </Step>

  <Step>
    ## Handle Failures and Rollback
    
    If deployment fails, execute the rollback task:

    ```bash
    # Manual rollback
    ./spry.ts rb task rollback deployment-runbook.md
    ```

    <Callout type="warning">
    **Error Handling**

    All tasks use `set -e` to fail fast on errors. The runbook stops at the first failure, preventing partial deployments and making it safe to retry.
    </Callout>
  </Step>
</Steps>

### Advanced Runbook Patterns

<Tabs items={['Environments', 'Notifications', 'Approval Gates']}>
  <Tab value="Environments">
    **Multi-Environment Deployments**

    Use environment variables to target different environments:

    ```bash
    # Development
    ENV=dev ./spry.ts rb run deployment-runbook.md

    # Staging
    ENV=staging ./spry.ts rb run deployment-runbook.md

    # Production
    ENV=production ./spry.ts rb run deployment-runbook.md
    ```

    In your runbook:
    ```bash
    SERVER_URL="${SERVER_URL:-http://${ENV:-dev}.example.com}"
    ```
  </Tab>

  <Tab value="Notifications">
    **Send Notifications**

    Add notification tasks for Slack, email, or PagerDuty:

    ```bash
    #!/usr/bin/env -S bash
    # Notify on deployment completion
    curl -X POST https://hooks.slack.com/services/YOUR/WEBHOOK/URL \
      -H 'Content-Type: application/json' \
      -d "{\"text\":\"Deployment completed successfully to ${ENV}\"}"
    ```
  </Tab>

  <Tab value="Approval Gates">
    **Manual Approval Gates**

    Add interactive approval steps:

    ```bash
    #!/usr/bin/env -S bash
    echo "About to deploy to PRODUCTION"
    echo "Type 'yes' to continue:"
    read confirmation

    if [ "$confirmation" != "yes" ]; then
      echo "Deployment cancelled"
      exit 1
    fi
    ```
  </Tab>
</Tabs>

---

## More Use Cases

<Cards>
  <Card title="Data Pipeline Orchestration" icon="GitBranch">
    Use Spry to orchestrate ETL jobs, with dependencies between extract, transform, and load steps
  </Card>
  
  <Card title="Infrastructure as Code" icon="Server">
    Define infrastructure provisioning steps with Terraform/CloudFormation in executable runbooks
  </Card>
  
  <Card title="Documentation Generation" icon="BookOpen">
    Generate API docs, diagrams, and reports from code annotations and metadata
  </Card>
  
  <Card title="Testing Frameworks" icon="CheckCircle">
    Build custom testing frameworks with dependency management and evidence collection
  </Card>
  
  <Card title="Release Automation" icon="Package">
    Automate version bumps, changelog generation, and release publishing
  </Card>
  
  <Card title="Database Migrations" icon="Database">
    Manage database schema changes with dependency-aware migration scripts
  </Card>
</Cards>

## Best Practices

### Document Structure

<Callout type="info">
**Organize for Readability**

Structure your Spryfiles for both humans and machines:
- Use clear section headings
- Document prerequisites and assumptions
- Include descriptive task names with `--descr`
- Add comments in code blocks
- Use frontmatter for metadata
</Callout>

### Dependency Management

**Good Dependency Patterns:**
- Make dependencies explicit with `--depends`
- Keep dependency chains reasonable (avoid deeply nested dependencies)
- Use parallel execution when tasks are independent
- Document why dependencies exist

**Example:**
```bash
# Good: Clear, explicit dependency
```bash deploy --depends build,test --descr "Deploy after build and tests pass"

# Avoid: Implicit ordering based on document position
```

### Error Handling

**Fail-Fast Pattern:**
```bash
#!/usr/bin/env -S bash
set -e  # Exit on any error
set -u  # Exit on undefined variable
set -o pipefail  # Exit if any pipe command fails

# Your commands here
```

**Graceful Degradation:**
```bash
#!/usr/bin/env -S bash
set -e

if ! command -v optional-tool &> /dev/null; then
  echo "WARNING: optional-tool not found, skipping optional step"
  exit 0  # Don't fail the whole pipeline
fi

optional-tool --do-something
```

### Testing Runbooks

<Steps>
  <Step>
    **Test in Isolation**
    
    Test individual tasks before running the full pipeline:
    ```bash
    ./spry.ts rb task build-app deployment-runbook.md
    ```
  </Step>

  <Step>
    **Dry Run Mode**
    
    Add a dry-run flag to preview without executing:
    ```bash
    DRY_RUN=true ./spry.ts rb run deployment-runbook.md
    ```

    In your scripts:
    ```bash
    if [ "${DRY_RUN:-false}" = "true" ]; then
      echo "DRY RUN: Would execute: command"
    else
      command
    fi
    ```
  </Step>

  <Step>
    **Version Control**
    
    Keep runbooks in git alongside your code:
    ```bash
    git add deployment-runbook.md
    git commit -m "Add automated deployment runbook"
    ```
  </Step>
</Steps>

## Next Steps

<Cards>
  <Card title="Core Concepts" href="/docs/core-concepts/spryfiles">
    Learn the fundamentals of Spryfiles and executable Markdown
  </Card>
  
  <Card title="CLI Reference" href="/docs/reference/cli-commands">
    Explore all available commands and options
  </Card>
  
  <Card title="SQLPage Guide" href="/docs/guides/sqlpage">
    Deep dive into building data applications
  </Card>
  
  <Card title="Task Dependencies" href="/docs/core-concepts/task-dependencies">
    Master dependency management and DAG execution
  </Card>
</Cards>

<Callout type="success">
**Start Building**

These recipes demonstrate Spry's versatility - from compliance automation to web applications to DevOps workflows. Pick a pattern that matches your needs and start building!
</Callout>